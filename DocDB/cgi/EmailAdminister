#! /usr/bin/env perl
#
#        Name: EmailAdminister
# Description: This script is called by EmailAdministerForm and does
#              administration on users who have signed up for email from the
#              DB. Since users can change almost everything, it really just
#              deletes users and changes their passwords in case they forget.
#              It also displays all the users and their notification
#              preferences.
#
#      Author: Eric Vaandering (ewv@fnal.gov)
#    Modified:
#

# Copyright 2001-2013 Eric Vaandering, Lynn Garren, Adam Bryant

#    This file is part of DocDB.

#    DocDB is free software; you can redistribute it and/or modify
#    it under the terms of version 2 of the GNU General Public License
#    as published by the Free Software Foundation.

#    DocDB is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.

#    You should have received a copy of the GNU General Public License
#    along with DocDB; if not, write to the Free Software
#    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA

use CGI;
use CGI::Untaint;
use DBI;

require "DocDBGlobals.pm";
require "ResponseElements.pm";
require "Security.pm";
require "HTMLUtilities.pm";
require "UntaintInput.pm";
require "SecuritySQL.pm";
require "NotificationSQL.pm";
require "Messages.pm";
require "EmailUserHTML.pm";
require "SignoffSQL.pm";

$query = new CGI;  # Global for subroutines
$query -> autoEscape(0);
my $Untaint = CGI::Untaint -> new($query -> Vars);

# Parameters to script

my $Password = $Untaint -> extract(-as_printable => "password") || "";
my $Username = $Untaint -> extract(-as_printable => "admuser") || "";
my $Action = $Untaint -> extract(-as_printable => "admaction") || "";

my $EmailUserID = $Untaint -> extract(-as_integer => "emailuserid") || 0;
my $NewCertID = $Untaint -> extract(-as_integer => "newcertid") || 0;
my $SingleUser = $Untaint -> extract(-as_safehtml => "singleuser") || "";
my $NewPassword = $Untaint -> extract(-as_printable => "resetpw") || "";

my $ClearGroups   = ($Untaint -> extract(-as_printable => "cleargroups") eq "on");
my $ClearUser     = ($Untaint -> extract(-as_printable => "clearuser")   eq "on");
my $UserSign      = ($Untaint -> extract(-as_printable => "usersign")    eq "on");
my $VerifyUser    = ($Untaint -> extract(-as_printable => "verifyuser")  eq "on");
my @UsersGroupIDs = @{ $Untaint -> extract(-as_listofint => "usergroups") || undef };

$dbh   = DBI->connect('DBI:mysql:'.$db_name.':'.$db_host,$Username,$Password);

unless ($dbh) {
  push @ErrorStack,$Msg_AdminNoConnect;
}

print $query -> header( -charset => $HTTP_ENCODING );
DocDBHeader("Modified E-mail Users");

EndPage();
GetSecurityGroups();

unless (CanAdminister()) {
  push @ErrorStack,$Msg_AdminNoLogin;
}
EndPage();

if      ($Action eq "Delete") { # Delete user
  if (!$EmailUserID) {
    push @ErrorStack,$Msg_ModEUserEmpty;
  } else {
    my $UserDelete         = $dbh -> prepare("delete from EmailUser    where EmailUserID=?");
    my $UsersGroupDelete   = $dbh -> prepare("delete from UsersGroup   where EmailUserID=?");
    my $NotificationDelete = $dbh -> prepare("delete from Notification where EmailUserID=?");
    $UsersGroupDelete   -> execute($EmailUserID);
    $NotificationDelete -> execute($EmailUserID);
    $UserDelete         -> execute($EmailUserID);

    my @NotifyTimes = ("Immediate","Daily","Weekly");
    my @NotifyTypes = ("Author","Keyword","Topic");
    foreach my $NotifyType (@NotifyTypes) {  # Loop over all tables and delete
      foreach my $NotifyTime (@NotifyTimes) {
        my $Table = "Email$NotifyType$NotifyTime";
        my $NotifyDelete = $dbh -> prepare("delete from $Table where EmailUserID=?");
           $NotifyDelete -> execute($EmailUserID);
      }
    }
    push @ActionStack,"The user was deleted.";
  }
  ActionReport();
} elsif ($Action eq "Modify") {
  unless ($EmailUserID) { # Deal with password changes
    push @ErrorStack,$Msg_ModEUserEmpty;
  }
  EndPage();

  FetchEmailUser($EmailUserID);

  if ($NewPassword) {
    srand (time ^ $$ ^ unpack "%32L*", `ps -eaf`);

    my $Salt = ((0..9,'a'..'z','A'..'Z','.','/')[(int rand (64))]).
               ((0..9,'a'..'z','A'..'Z','.','/')[(int rand (64))]);

    my $EncryptedPassword = crypt($NewPassword,$Salt);
    my $UserUpdate = $dbh -> prepare("update EmailUser set Password=? where EmailUserID=?");
       $UserUpdate -> execute($EncryptedPassword,$EmailUserID);
    push @ActionStack,"The User's password was changed. They should change it again ASAP.";
  }
  if ($ClearGroups || $SingleUser) {
    my $UsersGroupDelete = $dbh -> prepare("delete from UsersGroup where EmailUserID=?");
       $UsersGroupDelete -> execute($EmailUserID);
    push @ActionStack,"All associations between the user and groups have been deleted.";
  }
  if ($ClearUser || $SingleUser) {
    my $UserUpdate = $dbh -> prepare("update EmailUser set CanSign=0,Verified=0 where EmailUserID=?");
       $UserUpdate -> execute($EmailUserID);
    unless ($SingleUser) {
      push @ActionStack,"The user is no longer verified and cannot sign documents.";
    }
  }
  if ($UserSign) {
    my $UserUpdate = $dbh -> prepare("update EmailUser set CanSign=1 where EmailUserID=?");
       $UserUpdate -> execute($EmailUserID);
    push @ActionStack,"The user may sign documents.";
  }
  if ($VerifyUser) {
    my $UserUpdate = $dbh -> prepare("update EmailUser set Verified=1 where EmailUserID=?");
       $UserUpdate -> execute($EmailUserID);
    push @ActionStack,"The user is verified.";

    if ($MailInstalled && $UserValidation eq "certificate") {
      require "EmailUtilities.pm";

      my @To      = ($EmailUser{$EmailUserID}{EmailAddress},$DBWebMasterEmail);
      my $Subject = "DocDB account for $EmailUser{$EmailUserID}{Name} activated";
      my $Body    = "An administrator has approved the request for ";
      $Body      .= "$EmailUser{$EmailUserID}{Name} for access to $Project DocDB. ";
      $Body      .= "If you did not request access to $Project DocDB, ";
      $Body      .= "please contact $DBWebMasterEmail immediately.";
      SendEmail(-body => $Body, -to => \@To, -subject => $Subject);
    }
  }
  foreach my $UsersGroupID (@UsersGroupIDs) {
    my $UsersGroupSelect = $dbh -> prepare("select UsersGroupID from UsersGroup where EmailUserID=? and GroupID=?");
       $UsersGroupSelect -> execute($EmailUserID,$UsersGroupID);
    my ($ComboExists) = $UsersGroupSelect -> fetchrow_array;
    unless ($ComboExists) {
      my $UsersGroupUpdate = $dbh -> prepare("insert into UsersGroup (UsersGroupID,EmailUserID,GroupID) ".
                                             " values (0,?,?)");
         $UsersGroupUpdate -> execute($EmailUserID,$UsersGroupID);
      FetchSecurityGroup($UsersGroupID);
      push @ActionStack,"Added user to $SecurityGroups{$UsersGroupID}{NAME}";
    }
  }

  ClearEmailUsers();
  FetchEmailUser($EmailUserID);
  ActionReport();

  print "<h3>The user now has the following information:</h3>";
  print "<table class=\"LowPaddedTable\">\n";
  PrintEmailUserInfo($EmailUserID);
  print "</table>\n";

} elsif ($Action eq "Transfer") {

  # Consolidate certificates starting with basic settings

  if ($NewCertID) {
    FetchEmailUser($EmailUserID);
    FetchEmailUser($NewCertID);
    if ($EmailUser{$EmailUserID}{Name} && !$EmailUser{$NewCertID}{Name}) {
      my $UserUpdate = $dbh -> prepare("update EmailUser set Name=? where EmailUserID=?");
         $UserUpdate -> execute($EmailUser{$EmailUserID}{Name}, $NewCertID);
    }
    if ($EmailUser{$EmailUserID}{EmailAddress} && !$EmailUser{$NewCertID}{EmailAddress}) {
      my $UserUpdate = $dbh -> prepare("update EmailUser set EmailAddress=? where EmailUserID=?");
         $UserUpdate -> execute($EmailUser{$EmailUserID}{EmailAddress}, $NewCertID);
    }
    if ($EmailUser{$EmailUserID}{AuthorID} && !$EmailUser{$NewCertID}{AuthorID}) {
      my $UserUpdate = $dbh -> prepare("update EmailUser set AuthorID=? where EmailUserID=?");
         $UserUpdate -> execute($EmailUser{$EmailUserID}{AuthorID}, $NewCertID);
    }
    if ($EmailUser{$EmailUserID}{CanSign} && !$EmailUser{$NewCertID}{CanSign}) {
      my $UserUpdate = $dbh -> prepare("update EmailUser set CanSign=1 where EmailUserID=?");
         $UserUpdate -> execute($NewCertID);
    }
    if ($EmailUser{$EmailUserID}{Verified} && !$EmailUser{$NewCertID}{Verified}) {
      my $UserUpdate = $dbh -> prepare("update EmailUser set Verified=1 where EmailUserID=?");
         $UserUpdate -> execute($NewCertID);
    }

    # Update all notifications
    my $NotificationUpdate = $dbh -> prepare("update Notification set EmailUserID=? where EmailUserID=?");
       $NotificationUpdate -> execute($NewCertID, $EmailUserID);

    # Copy all groups
    my @UsersGroupIDs = FetchUserGroupIDs($EmailUserID);
    foreach my $UsersGroupID (@UsersGroupIDs) {
      my $UsersGroupSelect = $dbh -> prepare("select UsersGroupID from UsersGroup where EmailUserID=? and GroupID=?");
         $UsersGroupSelect -> execute($NewCertID,$UsersGroupID);
      my ($ComboExists) = $UsersGroupSelect -> fetchrow_array;
      unless ($ComboExists) {
        my $UsersGroupUpdate = $dbh -> prepare("insert into UsersGroup (UsersGroupID,EmailUserID,GroupID) ".
                                               " values (0,?,?)");
           $UsersGroupUpdate -> execute($NewCertID,$UsersGroupID);
        FetchSecurityGroup($UsersGroupID);
        push @ActionStack,"Added user to $SecurityGroups{$UsersGroupID}{NAME}";
      }
    }

    # Update signed signatures
    my $SignatureUpdate = $dbh -> prepare("update Signature set EmailUserID=? where EmailUserID=?");
       $SignatureUpdate -> execute($NewCertID, $EmailUserID);

    # Remove signature authority from the old account
    my $UserUpdate = $dbh -> prepare("update EmailUser set CanSign=0 where EmailUserID=?");
       $UserUpdate -> execute($EmailUserID);

  } # End of certificate consolidation

} elsif ($Action eq "New") {
  push @ErrorStack,"You can't create new users here. Do it the normal way.";
} else {
  push @ErrorStack,"No valid action was specified.";
}

EndPage();
WarnPage();

DocDBNavBar();
DocDBFooter($DBWebMasterEmail,$DBWebMasterName);

exit;
